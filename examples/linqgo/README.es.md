# LinqGo - Motor LINQ Universal para Go

Un motor LINQ completo y universal para Go, **100% compatible con .NET LINQ**, que funciona tanto con estructuras Go como con `map[string]interface{}` usando reflexi√≥n.

## üéØ Caracter√≠sticas

- **100% Compatible con .NET LINQ**: Sintaxis y operaciones id√©nticas a LINQ de .NET
- **Dual Data Support**: Funciona con estructuras Go y `map[string]interface{}`
- **DSL en Ingl√©s**: Sintaxis simplificada solo en ingl√©s para mayor estabilidad
- **API Fluida**: Sintaxis de encadenamiento como .NET LINQ
- **Operaciones Completas**: Where, Select, OrderBy, GroupBy, Take, Skip, etc.
- **Agregaciones**: Count, Sum, Average, Min, Max
- **Operaciones de Conjuntos**: Union, Intersect, Except
- **Cuantificadores**: Any, All, Contains
- **Consultas DSL**: Sintaxis SQL-like para consultas de texto
- **Alto Rendimiento**: Ejecuci√≥n en memoria con reflexi√≥n optimizada

## üöÄ Uso

```bash
cd examples/linqgo
go run main.go
```

## üìñ Sintaxis de Consultas DSL

### Patrones de Consultas B√°sicas
```sql
from ENTITY select FIELD
from ENTITY select *
from ENTITY where FIELD > VALUE select FIELD
from ENTITY where FIELD > VALUE select *
from ENTITY order by FIELD select FIELD
from ENTITY order by FIELD desc select FIELD
from ENTITY where FIELD > VALUE order by FIELD select FIELD
from ENTITY group by FIELD
from ENTITY group by FIELD select key
from ENTITY group by FIELD select count
```

## üîß Ejemplos de Consultas DSL (Solo Ingl√©s)

### Selecci√≥n B√°sica
```sql
from employee select name
from customer select *
from product order by price select name
```

### Filtrado
```sql
from employee where salary > 70000 select name
from customer where balance > 15000 select name
from product where price < 500 select name
from employee where department == Engineering select *
from customer where age >= 30 select name
from product where stock < 20 select name
```

### Ordenamiento
```sql
from employee order by salary select name
from customer order by balance desc select name
from product order by price desc select name
from employee where salary > 60000 order by age select name
```

### Agregaciones
```sql
from employee count
from employee sum salary
from customer avg balance
from product min price
from order max amount
from employee where department == Engineering sum salary
from customer where category == Premium avg balance
```

### Agrupamiento
```sql
from employee group by department
from customer group by country select key
from order group by status select count
from product group by category select key
```

### Paginaci√≥n
```sql
from employee take 5 select name
from customer skip 3 select name
from product skip 2 take 5 select *
from employee order by salary desc take 10 select name
```

### Consultas Distintas
```sql
from employee select distinct department
from customer select distinct country
from product distinct
from employee select distinct position
```

### Primera/√öltima
```sql
from employee first
from customer last
from product where price > 1000 first
from employee where department == Engineering first
```

### Consultas Combinadas Complejas
```sql
from employee where salary > 70000 order by salary desc select name
from customer where balance > 10000 order by balance desc take 5 select *
from product where price < 1000 order by rating desc select name
from employee where age > 30 order by salary desc take 3 select name
```

## üìä API Fluida (Program√°tica)

### Ejemplos con Estructuras Go
```go
// Importar
import "github.com/arturoeliasanton/go-dsl/examples/linqgo/universal"

// Definir estructura
type Employee struct {
    ID         int     `linq:"id"`
    Name       string  `linq:"name"`
    Department string  `linq:"department"`
    Salary     float64 `linq:"salary"`
    Age        int     `linq:"age"`
}

// Usar LINQ fluido
employees := []*Employee{...}

// Consulta compleja encadenada
highEarners := universal.From(employees).
    WhereField("salary", ">", 70000).
    OrderByFieldDescending("salary").
    SelectField("name").
    Take(3).
    ToSlice()

// Agregaciones
avgSalary := universal.From(employees).
    WhereField("department", "==", "Engineering").
    AverageField("salary")

// Agrupamiento
groupedByDept := universal.From(employees).
    GroupByField("department")
```

### Ejemplos con map[string]interface{}
```go
// Datos como mapas
projects := []map[string]interface{}{
    {"id": 1, "name": "Alpha", "budget": 100000.0, "status": "Active"},
    {"id": 2, "name": "Beta", "budget": 75000.0, "status": "Completed"},
}

// Convertir a interface{}
var projectsInterface []interface{}
for _, project := range projects {
    projectsInterface = append(projectsInterface, project)
}

// Usar LINQ
activeProjects := universal.From(projectsInterface).
    WhereField("status", "==", "Active").
    SumField("budget")
```

## üé≠ Operaciones Completas Soportadas

### Operaciones de Filtrado
- **Where** / **WhereField** - Filtrar elementos
- **Take** - Tomar primeros N elementos
- **Skip** - Saltar primeros N elementos
- **TakeWhile** - Tomar mientras condici√≥n sea verdadera
- **SkipWhile** - Saltar mientras condici√≥n sea verdadera
- **Distinct** / **DistinctBy** / **DistinctByField** - Elementos √∫nicos

### Operaciones de Proyecci√≥n
- **Select** / **SelectField** / **SelectFields** - Seleccionar/transformar elementos

### Operaciones de Ordenamiento
- **OrderBy** / **OrderByField** - Ordenar ascendente
- **OrderByDescending** / **OrderByFieldDescending** - Ordenar descendente
- **Reverse** - Invertir orden

### Operaciones de Agrupamiento
- **GroupBy** / **GroupByField** - Agrupar elementos

### Operaciones de Conjuntos
- **Union** - Uni√≥n de dos secuencias (sin duplicados)
- **Intersect** - Intersecci√≥n de dos secuencias
- **Except** - Diferencia de dos secuencias

### Operaciones de Agregaci√≥n
- **Count** / **CountWhere** - Contar elementos
- **Sum** / **SumField** - Sumar valores num√©ricos
- **Average** / **AverageField** - Calcular promedio
- **Min** / **MinField** - Encontrar m√≠nimo
- **Max** / **MaxField** - Encontrar m√°ximo
- **Aggregate** - Agregaci√≥n personalizada

### Operaciones de Cuantificaci√≥n
- **Any** - ¬øAlg√∫n elemento cumple condici√≥n?
- **All** - ¬øTodos los elementos cumplen condici√≥n?
- **Contains** - ¬øContiene elemento espec√≠fico?

### Operaciones de Elemento
- **First** / **FirstWhere** / **FirstOrDefault** - Primer elemento
- **Last** / **LastWhere** / **LastOrDefault** - √öltimo elemento
- **Single** / **SingleOrDefault** - Elemento √∫nico

## üèóÔ∏è Tipos de Datos Soportados

### Estructuras Go con Tags
```go
type Customer struct {
    ID       int     `linq:"id"`
    Name     string  `linq:"name"`
    Email    string  `linq:"email"`
    Balance  float64 `linq:"balance"`
    Category string  `linq:"category"`
}
```

### Mapas de Interfaz
```go
data := []map[string]interface{}{
    {"id": 1, "name": "John", "salary": 75000.0},
    {"id": 2, "name": "Jane", "salary": 85000.0},
}
```

### Cualquier Tipo de Slice
```go
// LinqGo funciona con cualquier []interface{}
var anyData []interface{}
anyData = append(anyData, customer1, customer2, customer3)

result := universal.From(anyData).
    WhereField("category", "==", "Premium").
    ToSlice()
```

## ‚öôÔ∏è Operadores Soportados

### Operadores de Comparaci√≥n
- `==`, `equals`, `eq` - Igualdad
- `!=`, `not_equals`, `ne` - Desigualdad
- `>`, `greater`, `gt` - Mayor que
- `>=`, `greater_equal`, `ge` - Mayor o igual
- `<`, `less`, `lt` - Menor que
- `<=`, `less_equal`, `le` - Menor o igual

### Operadores de Texto
- `contains` - Contiene texto
- `starts_with` - Empieza con
- `ends_with` - Termina con

## üéØ Casos de Uso Empresariales

- **An√°lisis de Datos**: Procesar grandes conjuntos de datos empresariales
- **Reportes**: Generar reportes complejos con agregaciones
- **APIs REST**: Filtrar y paginar resultados de APIs
- **Business Intelligence**: An√°lisis de datos de negocio
- **ETL Processes**: Transformaci√≥n de datos entre sistemas
- **Data Mining**: Miner√≠a de datos con operaciones complejas
- **Dashboards**: Preparar datos para visualizaciones
- **Microservicios**: Procesamiento de datos entre servicios

## üöÄ Rendimiento y Caracter√≠sticas

### Ventajas de Rendimiento
- **Ejecuci√≥n en Memoria**: Todas las operaciones se ejecutan in-memory
- **Reflexi√≥n Optimizada**: Uso eficiente de reflexi√≥n de Go
- **Lazy Evaluation**: Evaluaci√≥n perezosa donde es posible
- **Zero Dependencies**: Solo depende de go-dsl

### Caracter√≠sticas Empresariales
- ‚úÖ **Type Safety** - Seguridad de tipos con manejo de errores
- ‚úÖ **Thread Safe** - Seguro para uso concurrente
- ‚úÖ **Memory Efficient** - Uso eficiente de memoria
- ‚úÖ **Error Handling** - Manejo robusto de errores
- ‚úÖ **Extensible** - F√°cil de extender con nuevas operaciones
- ‚úÖ **Production Ready** - Listo para producci√≥n

## üåü Comparaci√≥n con .NET LINQ

| Caracter√≠stica | .NET LINQ | LinqGo | Estado |
|---------------|-----------|--------|--------|
| Where | ‚úÖ | ‚úÖ | Completo |
| Select | ‚úÖ | ‚úÖ | Completo |
| OrderBy | ‚úÖ | ‚úÖ | Completo |
| GroupBy | ‚úÖ | ‚úÖ | Completo |
| Take/Skip | ‚úÖ | ‚úÖ | Completo |
| Distinct | ‚úÖ | ‚úÖ | Completo |
| Union/Intersect | ‚úÖ | ‚úÖ | Completo |
| Any/All | ‚úÖ | ‚úÖ | Completo |
| Count/Sum/Avg | ‚úÖ | ‚úÖ | Completo |
| First/Last | ‚úÖ | ‚úÖ | Completo |
| Aggregate | ‚úÖ | ‚úÖ | Completo |
| Join | ‚úÖ | üöß | En desarrollo |
| Sintaxis DSL | ‚ùå | ‚úÖ | Ventaja de LinqGo |

## üìà Ejemplos de Rendimiento

```go
// Procesamiento de 10,000 empleados
employees := make([]*Employee, 10000)
// ... llenar datos

// Consulta compleja en una sola l√≠nea
result := universal.From(employees).
    WhereField("department", "==", "Engineering").
    WhereField("salary", ">", 70000).
    OrderByFieldDescending("salary").
    Take(100).
    SelectFields("name", "salary", "department").
    ToSlice()

// Estad√≠sticas por departamento
stats := universal.From(employees).
    GroupByField("department")

for _, group := range stats {
    avgSalary := universal.From(group.Items).AverageField("salary")
    fmt.Printf("%s: %d empleados, salario promedio: %.2f\n", 
        group.Key, group.Count, avgSalary)
}
```

¬°El motor LINQ m√°s completo y competitivo para Go! üöÄ