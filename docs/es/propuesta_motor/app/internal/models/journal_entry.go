package models

import (
	"encoding/json"
	"time"
)

// JournalEntry representa un asiento contable en el libro diario
// Se genera automáticamente desde comprobantes o manualmente
type JournalEntry struct {
	BaseModel
	OrganizationID      string    `json:"organization_id" gorm:"index;not null"`
	EntryNumber         string    `json:"entry_number" gorm:"uniqueIndex:idx_org_entry;not null"`
	Date                time.Time `json:"date" gorm:"not null;index"`
	Description         string    `json:"description" gorm:"not null"`
	Reference           string    `json:"reference"`
	VoucherID           *string   `json:"voucher_id" gorm:"index"` // NULL para asientos manuales
	PeriodID            string    `json:"period_id" gorm:"index;not null"`
	Status              string    `json:"status" gorm:"default:'POSTED'"` // POSTED, REVERSED
	TotalDebit          float64   `json:"total_debit" gorm:"type:decimal(15,2);default:0"`
	TotalCredit         float64   `json:"total_credit" gorm:"type:decimal(15,2);default:0"`
	IsReversed          bool      `json:"is_reversed" gorm:"default:false"`
	ReversedByEntryID   *string   `json:"reversed_by_entry_id" gorm:"index"`
	ReversalReason      string    `json:"reversal_reason"`
	CreatedByUserID     string    `json:"created_by_user_id" gorm:"index"`
	PostedAt            time.Time `json:"posted_at" gorm:"not null"`
	MetadataJSON        string    `json:"-" gorm:"type:text;column:metadata"`
	JournalLines        []JournalLine `json:"journal_lines" gorm:"foreignKey:JournalEntryID;constraint:OnDelete:CASCADE"`
}

// JournalLine representa una línea de asiento contable
type JournalLine struct {
	BaseModel
	JournalEntryID  string  `json:"journal_entry_id" gorm:"index;not null"`
	AccountID       string  `json:"account_id" gorm:"index;not null"`
	Description     string  `json:"description" gorm:"not null"`
	DebitAmount     float64 `json:"debit_amount" gorm:"type:decimal(15,2);default:0"`
	CreditAmount    float64 `json:"credit_amount" gorm:"type:decimal(15,2);default:0"`
	ThirdPartyID    *string `json:"third_party_id" gorm:"index"`
	CostCenterID    *string `json:"cost_center_id" gorm:"index"`
	LineNumber      int     `json:"line_number" gorm:"not null"`
	VoucherLineID   *string `json:"voucher_line_id" gorm:"index"` // Referencia a línea del comprobante origen
	
	// Relaciones
	Account       *Account      `json:"account,omitempty" gorm:"foreignKey:AccountID"`
	ThirdParty    *ThirdParty   `json:"third_party,omitempty" gorm:"foreignKey:ThirdPartyID"`
	JournalEntry  *JournalEntry `json:"journal_entry,omitempty" gorm:"foreignKey:JournalEntryID"`
}

// JournalEntryMetadata metadatos adicionales del asiento
type JournalEntryMetadata struct {
	SourceType      string                 `json:"source_type"` // VOUCHER, MANUAL, ADJUSTMENT, CLOSING
	AutoGenerated   bool                   `json:"auto_generated"`
	DSLGenerated    bool                   `json:"dsl_generated"`
	TemplateID      string                 `json:"template_id,omitempty"`
	ProcessingInfo  map[string]interface{} `json:"processing_info,omitempty"`
	CustomFields    map[string]interface{} `json:"custom_fields,omitempty"`
}

// GetMetadata deserializa los metadatos del asiento
func (je *JournalEntry) GetMetadata() (*JournalEntryMetadata, error) {
	if je.MetadataJSON == "" {
		return &JournalEntryMetadata{}, nil
	}
	var metadata JournalEntryMetadata
	err := json.Unmarshal([]byte(je.MetadataJSON), &metadata)
	return &metadata, err
}

// SetMetadata serializa los metadatos del asiento
func (je *JournalEntry) SetMetadata(metadata JournalEntryMetadata) error {
	data, err := json.Marshal(metadata)
	if err != nil {
		return err
	}
	je.MetadataJSON = string(data)
	return nil
}

// CalculateTotals calcula los totales del asiento
func (je *JournalEntry) CalculateTotals() {
	var totalDebit, totalCredit float64
	for _, line := range je.JournalLines {
		totalDebit += line.DebitAmount
		totalCredit += line.CreditAmount
	}
	je.TotalDebit = totalDebit
	je.TotalCredit = totalCredit
}

// IsBalanced verifica si el asiento está balanceado
func (je *JournalEntry) IsBalanced() bool {
	return je.TotalDebit == je.TotalCredit && je.TotalDebit > 0
}

// JournalEntryDetail estructura completa para respuestas detalladas
type JournalEntryDetail struct {
	*JournalEntry
	Metadata      *JournalEntryMetadata `json:"metadata"`
	Voucher       *Voucher              `json:"voucher,omitempty"`
	Period        *Period               `json:"period,omitempty"`
	ReversedBy    *JournalEntry         `json:"reversed_by,omitempty"`
}

// ToDetail convierte un JournalEntry a JournalEntryDetail con metadatos
func (je *JournalEntry) ToDetail() (*JournalEntryDetail, error) {
	metadata, err := je.GetMetadata()
	if err != nil {
		return nil, err
	}
	
	return &JournalEntryDetail{
		JournalEntry: je,
		Metadata:     metadata,
	}, nil
}

// JournalEntryCreateRequest estructura para crear asientos contables
type JournalEntryCreateRequest struct {
	Date         time.Time              `json:"date" binding:"required"`
	Description  string                 `json:"description" binding:"required"`
	Reference    string                 `json:"reference"`
	JournalLines []JournalLineRequest   `json:"journal_lines" binding:"required,min=2"`
	Metadata     *JournalEntryMetadata  `json:"metadata"`
}

// JournalLineRequest estructura para líneas de asiento en requests
type JournalLineRequest struct {
	AccountID       string  `json:"account_id" binding:"required"`
	Description     string  `json:"description" binding:"required"`
	DebitAmount     float64 `json:"debit_amount"`
	CreditAmount    float64 `json:"credit_amount"`
	ThirdPartyID    *string `json:"third_party_id"`
	CostCenterID    *string `json:"cost_center_id"`
}

// JournalEntriesListResponse respuesta para listado de asientos
type JournalEntriesListResponse struct {
	JournalEntries []JournalEntry  `json:"journal_entries"`
	Pagination     *PaginationInfo `json:"pagination"`
}

// JournalEntryReversalRequest estructura para reversión de asientos
type JournalEntryReversalRequest struct {
	ReversalDate   time.Time `json:"reversal_date" binding:"required"`
	ReversalReason string    `json:"reversal_reason" binding:"required"`
}

// TrialBalanceEntry entrada del balance de comprobación
type TrialBalanceEntry struct {
	AccountID      string  `json:"account_id"`
	AccountCode    string  `json:"account_code"`
	AccountName    string  `json:"account_name"`
	AccountType    string  `json:"account_type"`
	Level          int     `json:"level"`
	InitialDebit   float64 `json:"initial_debit"`
	InitialCredit  float64 `json:"initial_credit"`
	MovementDebit  float64 `json:"movement_debit"`
	MovementCredit float64 `json:"movement_credit"`
	FinalDebit     float64 `json:"final_debit"`
	FinalCredit    float64 `json:"final_credit"`
}

// TrialBalanceResponse respuesta del balance de comprobación
type TrialBalanceResponse struct {
	PeriodID     string              `json:"period_id"`
	PeriodName   string              `json:"period_name"`
	GeneratedAt  time.Time           `json:"generated_at"`
	Entries      []TrialBalanceEntry `json:"entries"`
	TotalDebit   float64             `json:"total_debit"`
	TotalCredit  float64             `json:"total_credit"`
	IsBalanced   bool                `json:"is_balanced"`
}

// JSONTime custom time type for JSON compatibility
type JSONTime struct {
	time.Time
}

// MarshalJSON implements json.Marshaler
func (jt JSONTime) MarshalJSON() ([]byte, error) {
	return json.Marshal(jt.Time)
}

// JournalEntriesListResponseForFrontend respuesta compatible con frontend
type JournalEntriesListResponseForFrontend struct {
	Entries []JournalEntryForFrontend `json:"entries"`
	Summary JournalEntrySummary       `json:"summary"`
}

// JournalEntrySummary resumen de asientos
type JournalEntrySummary struct {
	TotalEntries  int     `json:"total_entries"`
	TotalDebits   float64 `json:"total_debits"`
	TotalCredits  float64 `json:"total_credits"`
	Balance       float64 `json:"balance"`
}

// JournalEntryForFrontend asiento contable compatible con frontend
type JournalEntryForFrontend struct {
	ID            string                    `json:"id"`
	EntryNumber   string                    `json:"entry_number"`
	EntryDate     string                    `json:"entry_date"`
	Description   string                    `json:"description"`
	VoucherNumber *string                   `json:"voucher_number"`
	Status        string                    `json:"status"`
	Lines         []JournalLineForFrontend  `json:"lines"`
	CreatedAt     time.Time                 `json:"created_at"`
	UpdatedAt     time.Time                 `json:"updated_at"`
}

// JournalLineForFrontend línea de asiento compatible con frontend
type JournalLineForFrontend struct {
	AccountCode string  `json:"account_code"`
	AccountName string  `json:"account_name"`
	Description string  `json:"description"`
	Debit       float64 `json:"debit"`
	Credit      float64 `json:"credit"`
}

// ToFrontendFormat convierte JournalEntry a formato compatible con frontend
func (je *JournalEntry) ToFrontendFormat() JournalEntryForFrontend {
	lines := make([]JournalLineForFrontend, len(je.JournalLines))
	for i, line := range je.JournalLines {
		accountCode := ""
		accountName := ""
		if line.Account != nil {
			accountCode = line.Account.Code
			accountName = line.Account.Name
		}
		
		lines[i] = JournalLineForFrontend{
			AccountCode: accountCode,
			AccountName: accountName,
			Description: line.Description,
			Debit:       line.DebitAmount,
			Credit:      line.CreditAmount,
		}
	}

	var voucherNumber *string
	// En el POC, no tenemos referencia directa al voucher, así que lo dejamos nil

	return JournalEntryForFrontend{
		ID:            je.ID,
		EntryNumber:   je.EntryNumber,
		EntryDate:     je.Date.Format("2006-01-02"),
		Description:   je.Description,
		VoucherNumber: voucherNumber,
		Status:        je.Status,
		Lines:         lines,
		CreatedAt:     je.CreatedAt,
		UpdatedAt:     je.UpdatedAt,
	}
}