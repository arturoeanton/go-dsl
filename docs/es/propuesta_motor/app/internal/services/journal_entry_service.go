package services

import (
	"errors"
	"fmt"
	"motor-contable-poc/internal/data"
	"motor-contable-poc/internal/models"
	"time"

	"gorm.io/gorm"
)

// JournalEntryService maneja la lógica de negocio para asientos contables
type JournalEntryService struct {
	journalRepo *data.JournalEntryRepository
	accountRepo *data.AccountRepository
}

// NewJournalEntryService crea una nueva instancia del servicio
func NewJournalEntryService(db *gorm.DB) *JournalEntryService {
	return &JournalEntryService{
		journalRepo: data.NewJournalEntryRepository(db),
		accountRepo: data.NewAccountRepository(db),
	}
}

// GetList obtiene una lista paginada de asientos contables
func (s *JournalEntryService) GetList(orgID string, page, perPage int) (*models.JournalEntriesListResponseForFrontend, error) {
	entries, total, err := s.journalRepo.GetByOrganization(orgID, page, perPage)
	if err != nil {
		return nil, err
	}

	// Convertir a formato de frontend
	frontendEntries := make([]models.JournalEntryForFrontend, len(entries))
	var totalDebits, totalCredits float64

	for i, entry := range entries {
		frontendEntries[i] = entry.ToFrontendFormat()
		totalDebits += entry.TotalDebit
		totalCredits += entry.TotalCredit
	}

	response := &models.JournalEntriesListResponseForFrontend{
		Entries: frontendEntries,
		Summary: models.JournalEntrySummary{
			TotalEntries: int(total),
			TotalDebits:  totalDebits,
			TotalCredits: totalCredits,
			Balance:      totalDebits - totalCredits,
		},
	}

	return response, nil
}

// GetByID obtiene un asiento por ID
func (s *JournalEntryService) GetByID(id string) (*models.JournalEntryDetail, error) {
	entry, err := s.journalRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	return entry.ToDetail()
}

// Create crea un nuevo asiento contable
func (s *JournalEntryService) Create(orgID string, request models.JournalEntryCreateRequest) (*models.JournalEntry, error) {
	// Validar que las líneas están balanceadas
	err := s.validateJournalLines(request.JournalLines)
	if err != nil {
		return nil, err
	}

	// Validar que las cuentas existen y aceptan movimiento
	err = s.validateAccounts(orgID, request.JournalLines)
	if err != nil {
		return nil, err
	}

	// Generar número automático
	number, err := s.journalRepo.GetNextNumber(orgID)
	if err != nil {
		return nil, err
	}

	// Crear el asiento
	entry := &models.JournalEntry{
		OrganizationID:  orgID,
		EntryNumber:     number,
		Date:            request.Date,
		Description:     request.Description,
		Reference:       request.Reference,
		PeriodID:        s.getCurrentPeriodID(orgID),
		Status:          "POSTED", // Asientos manuales se crean directamente contabilizados
		CreatedByUserID: "system", // TODO: Obtener del contexto
		PostedAt:        time.Now(),
	}

	// Convertir líneas del request
	for i, lineReq := range request.JournalLines {
		line := models.JournalLine{
			AccountID:    lineReq.AccountID,
			Description:  lineReq.Description,
			DebitAmount:  lineReq.DebitAmount,
			CreditAmount: lineReq.CreditAmount,
			ThirdPartyID: lineReq.ThirdPartyID,
			CostCenterID: lineReq.CostCenterID,
			LineNumber:   i + 1,
		}
		entry.JournalLines = append(entry.JournalLines, line)
	}

	// Calcular totales
	entry.CalculateTotals()

	// Establecer metadatos si se proporcionan
	if request.Metadata != nil {
		err = entry.SetMetadata(*request.Metadata)
		if err != nil {
			return nil, err
		}
	} else {
		// Metadatos por defecto para asientos manuales
		metadata := models.JournalEntryMetadata{
			SourceType:    "MANUAL",
			AutoGenerated: false,
			DSLGenerated:  false,
		}
		err = entry.SetMetadata(metadata)
		if err != nil {
			return nil, err
		}
	}

	// Crear en la base de datos
	err = s.journalRepo.Create(entry)
	if err != nil {
		return nil, err
	}

	return entry, nil
}

// Post contabiliza un asiento (ya implementado en Create para asientos manuales)
func (s *JournalEntryService) Post(entryID, userID string) error {
	entry, err := s.journalRepo.GetByID(entryID)
	if err != nil {
		return err
	}

	if entry.Status == "POSTED" {
		return errors.New("el asiento ya está contabilizado")
	}

	if entry.IsReversed {
		return errors.New("no se puede contabilizar un asiento reversado")
	}

	if !entry.IsBalanced() {
		return errors.New("el asiento debe estar balanceado para ser contabilizado")
	}

	return s.journalRepo.Post(entryID, userID)
}

// Reverse crea un asiento de reversión
func (s *JournalEntryService) Reverse(entryID, userID string) (*models.JournalEntry, error) {
	originalEntry, err := s.journalRepo.GetByID(entryID)
	if err != nil {
		return nil, err
	}

	if originalEntry.Status != "POSTED" {
		return nil, errors.New("solo se pueden reversar asientos contabilizados")
	}

	if originalEntry.IsReversed {
		return nil, errors.New("el asiento ya ha sido reversado")
	}

	// Crear asiento de reversión
	reversalNumber, err := s.journalRepo.GetNextNumber(originalEntry.OrganizationID)
	if err != nil {
		return nil, err
	}

	reversalEntry := &models.JournalEntry{
		OrganizationID:  originalEntry.OrganizationID,
		EntryNumber:     reversalNumber,
		Date:            time.Now(),
		Description:     fmt.Sprintf("Reversión de %s - %s", originalEntry.EntryNumber, originalEntry.Description),
		Reference:       "REV-" + originalEntry.EntryNumber,
		PeriodID:        s.getCurrentPeriodID(originalEntry.OrganizationID),
		Status:          "POSTED",
		CreatedByUserID: userID,
		PostedAt:        time.Now(),
	}

	// Crear líneas de reversión (invertir débitos y créditos)
	for i, line := range originalEntry.JournalLines {
		reversalLine := models.JournalLine{
			AccountID:    line.AccountID,
			Description:  "Reversión - " + line.Description,
			DebitAmount:  line.CreditAmount,  // Invertir
			CreditAmount: line.DebitAmount,   // Invertir
			ThirdPartyID: line.ThirdPartyID,
			CostCenterID: line.CostCenterID,
			LineNumber:   i + 1,
		}
		reversalEntry.JournalLines = append(reversalEntry.JournalLines, reversalLine)
	}

	// Calcular totales
	reversalEntry.CalculateTotals()

	// Establecer metadatos
	metadata := models.JournalEntryMetadata{
		SourceType:    "REVERSAL",
		AutoGenerated: true,
		DSLGenerated:  false,
	}
	err = reversalEntry.SetMetadata(metadata)
	if err != nil {
		return nil, err
	}

	// Crear el asiento de reversión
	err = s.journalRepo.Create(reversalEntry)
	if err != nil {
		return nil, err
	}

	// Marcar el asiento original como reversado
	err = s.journalRepo.MarkAsReversed(entryID, reversalEntry.ID)
	if err != nil {
		return nil, err
	}

	return reversalEntry, nil
}

// validateJournalLines valida que las líneas del asiento estén balanceadas
func (s *JournalEntryService) validateJournalLines(lines []models.JournalLineRequest) error {
	var totalDebit, totalCredit float64

	if len(lines) < 2 {
		return errors.New("un asiento debe tener al menos 2 líneas")
	}

	for _, line := range lines {
		totalDebit += line.DebitAmount
		totalCredit += line.CreditAmount

		// Validar que cada línea tenga movimiento en un solo lado
		if line.DebitAmount > 0 && line.CreditAmount > 0 {
			return errors.New("una línea no puede tener valores tanto en débito como en crédito")
		}

		if line.DebitAmount == 0 && line.CreditAmount == 0 {
			return errors.New("una línea debe tener valor en débito o crédito")
		}
	}

	// Validar que esté balanceado
	if totalDebit != totalCredit {
		return fmt.Errorf("el asiento no está balanceado: débitos=%.2f, créditos=%.2f", totalDebit, totalCredit)
	}

	return nil
}

// validateAccounts valida que las cuentas existan y acepten movimiento
func (s *JournalEntryService) validateAccounts(orgID string, lines []models.JournalLineRequest) error {
	for _, line := range lines {
		account, err := s.accountRepo.GetByID(line.AccountID)
		if err != nil {
			return fmt.Errorf("cuenta %s no encontrada", line.AccountID)
		}

		if account.OrganizationID != orgID {
			return fmt.Errorf("cuenta %s no pertenece a la organización", line.AccountID)
		}

		if !account.AcceptsMovement {
			return fmt.Errorf("la cuenta %s (%s) no acepta movimiento directo", account.Code, account.Name)
		}

		if !account.IsActive {
			return fmt.Errorf("la cuenta %s (%s) no está activa", account.Code, account.Name)
		}
	}

	return nil
}

// getCurrentPeriodID obtiene el ID del período actual
func (s *JournalEntryService) getCurrentPeriodID(orgID string) string {
	// Placeholder - en la implementación real esto vendría de un servicio de períodos
	return "current-period-id"
}

// CreateFromVoucher crea un asiento contable desde un comprobante
func (s *JournalEntryService) CreateFromVoucher(voucher *models.Voucher, userID string) (*models.JournalEntry, error) {
	// Validar que el comprobante esté balanceado
	if !voucher.IsBalanced {
		return nil, errors.New("el comprobante debe estar balanceado")
	}
	
	// Generar número de asiento
	entryNumber, err := s.journalRepo.GetNextNumber(voucher.OrganizationID)
	if err != nil {
		return nil, err
	}
	
	// Crear el asiento contable
	journalEntry := &models.JournalEntry{
		OrganizationID:  voucher.OrganizationID,
		EntryNumber:     entryNumber,
		Date:            voucher.Date,
		Description:     fmt.Sprintf("Asiento de %s - %s", voucher.VoucherType, voucher.Description),
		Reference:       voucher.Number,
		VoucherID:       &voucher.ID,
		PeriodID:        voucher.PeriodID,
		Status:          "POSTED",
		CreatedByUserID: userID,
		PostedAt:        time.Now(),
	}
	
	// Convertir líneas del comprobante a líneas del asiento
	for i, voucherLine := range voucher.VoucherLines {
		journalLine := models.JournalLine{
			AccountID:     voucherLine.AccountID,
			Description:   voucherLine.Description,
			DebitAmount:   voucherLine.DebitAmount,
			CreditAmount:  voucherLine.CreditAmount,
			ThirdPartyID:  voucherLine.ThirdPartyID,
			CostCenterID:  voucherLine.CostCenterID,
			LineNumber:    i + 1,
			VoucherLineID: &voucherLine.ID,
		}
		journalEntry.JournalLines = append(journalEntry.JournalLines, journalLine)
	}
	
	// Calcular totales
	journalEntry.CalculateTotals()
	
	// Establecer metadatos
	metadata := models.JournalEntryMetadata{
		SourceType:    "VOUCHER",
		AutoGenerated: true,
		DSLGenerated:  false, // Por ahora no usamos DSL
		ProcessingInfo: map[string]interface{}{
			"voucher_id":     voucher.ID,
			"voucher_type":   voucher.VoucherType,
			"voucher_number": voucher.Number,
		},
	}
	
	if err := journalEntry.SetMetadata(metadata); err != nil {
		return nil, err
	}
	
	// Crear en la base de datos
	if err := s.journalRepo.Create(journalEntry); err != nil {
		return nil, err
	}
	
	return journalEntry, nil
}